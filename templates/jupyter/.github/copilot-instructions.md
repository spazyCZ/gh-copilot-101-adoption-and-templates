# Copilot Instructions for Jupyter Notebooks

## Table of Contents
- [Introduction](#introduction)
- [Key Objectives](#key-objectives)
- [Core Guidelines](#core-guidelines)
  - [Documentation Standards](#1-documentation-standards)
  - [Type Safety](#2-type-safety)
  - [Testing Best Practices](#3-testing-best-practices)
  - [Logging Standards](#4-logging-standards)
  - [Package Management](#5-package-management)
  - [Cell Organization](#6-cell-organization)
  - [Markdown Best Practices](#7-markdown-best-practices)
- [Visualization Standards](#visualization-standards)
- [Coding Style and Best Practices](#coding-style-and-best-practices)
- [Conclusion](#conclusion)

## Introduction
These instructions provide best practices for generating Jupyter notebooks using GitHub Copilot. The focus is on clear, maintainable, and reproducible notebooks for data analysis and visualization.

## Key Objectives
✓ Generate clear, maintainable, and reproducible notebooks
✓ Include thorough documentation and type annotations in code cells
✓ Use open-source quality code and documentation
✓ Ensure all code is well-documented and easy to follow

## Core Guidelines

### 1. Documentation Standards
- Every function and class in code cells must have docstrings explaining their purpose, parameters, and return values.
- Use markdown cells to explain the purpose of each section and important steps in the analysis.

### 2. Type Safety
- All functions in code cells must declare data types for parameters and return values using type hints.
- Example:
  ```python
  def add_numbers(a: int, b: int) -> int:
      """
      Adds two integers and returns the sum.
      :param a: First integer.
      :param b: Second integer.
      :return: The sum of a and b.
      """
      return a + b
  ```

### 3. Testing Best Practices
- Place reusable logic in separate Python modules (e.g., in a `src/` folder) and import them into notebooks.
- For notebook code, use assertions within cells to validate assumptions and results:
  ```python
  assert df.shape[0] > 0, "DataFrame is empty"
  assert not df.isnull().any().any(), "DataFrame contains null values"
  ```
- For reusable modules, write unit tests in separate test files using `pytest`.
- Mark all AI-generated tests for manual review as follows:
  ```python
  # === TEST GENERATED BY AI (GitHub Copilot) ===
  # Please manually review this test for correctness and completeness.
  ```
- Use clear and consistent naming conventions for test files.

### 4. Logging Standards
- Use Python's `logging` module for event and error reporting in code cells, not print statements.
- Example:
  ```python
  import logging
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger(__name__)
  ```

### 5. Package Management
- Include a `requirements.txt` file with all dependencies and their versions.
- Add a setup cell at the beginning of the notebook to install required packages using the Jupyter magic command:
  ```python
  # Install required packages
  %pip install pandas>=1.5.0 numpy>=1.22.0 matplotlib>=3.5.0 seaborn>=0.12.0
  
  # Alternatively, install from requirements.txt
  %pip install -r requirements.txt
  ```
- Always specify version requirements to ensure reproducibility.
- The `%pip` magic command is preferred over other approaches as it's specifically designed for Jupyter notebooks.
- Comment the installation cell if targeting environments where pip installs are not allowed.

### 6. Cell Organization
- Organize notebook cells in a logical progression (imports → data loading → exploration → analysis → visualization → conclusion).
- Keep code cells short and focused on a single task (aim for <15 lines per cell when possible).
- Begin each major section with a markdown header cell that summarizes its purpose.
- Avoid mixing unrelated operations in a single cell.
- Include checkpoint cells that save intermediate results for long operations.
- Ensure the notebook can run from top to bottom without errors.
- Add cell tags when needed for cell execution control or slideshow formatting.

### 7. Markdown Best Practices
- Use heading levels consistently (H1 for title, H2 for main sections, H3 for subsections).
- Include a table of contents for longer notebooks.
- Use formatted text (bold, italic) to emphasize important points.
- Include explanations of your analysis and findings in markdown cells.
- Format tables using markdown syntax for presenting structured results.
- Reference external resources with properly formatted links.
- Use LaTeX (via MathJax) for mathematical formulas and equations:
  ```
  $y = mx + b$
  $$\frac{d}{dx}(x^n) = nx^{n-1}$$
  ```

## Visualization Standards
- Use seaborn and matplotlib for consistent visualization styling.
- Include titles, axis labels, and legends for all plots.
- Use a consistent color palette throughout the notebook (e.g., `sns.set_palette("viridis")`).
- Adjust figure size for readability: `plt.figure(figsize=(10, 6))`.
- Add captions in markdown cells explaining the significance of visualizations.
- Use subplots for related visualizations: `fig, axes = plt.subplots(1, 2, figsize=(12, 5))`.
- Add annotations to highlight key points in visualizations.
- Set a standard style for all plots: `sns.set_theme(style="whitegrid")`.
- Consider colorblind-friendly palettes: `sns.color_palette("colorblind")`.

## Coding Style and Best Practices
- **Modularity**: Place reusable code in modules, not in notebook cells.
- **Consistency**: Use consistent naming conventions and code formatting.
- **Error Handling**: Use try/except blocks and log errors where appropriate.
- **Documentation**: Use markdown and comments to explain all steps and code.
- **Performance**: Use vectorized operations when working with pandas/numpy.

## Conclusion
These instructions ensure that Jupyter notebooks are efficient, well-documented, and reproducible. Following these guidelines will result in professional, shareable, and maintainable data analysis projects.
